-------------------------------------
	Concurrency
-------------------------------------


	Questions


1.	How can you create a thread?
#################Response:
Creating and using a thread in Java is as simple as creating an object of the Thread class and using that object in a program.
Creating an object of the Thread class allocates memory for that object on the heap.
It does not start or run the thread.
After you have created an object of the Thread class, you must call its start() method to start the thread represented by that object.
There are three ways you can specify your code to be executed by a thread:
• By inheriting your class from the Thread class
• By implementing the Runnable interface in your class
• By using the method reference to a method that takes no parameters and returns void

2.	Can a program terminate in case some of its threads are still running?
#################Response:


3.	How can you wait for another thread to complete?
#################Response:


4.	Which lock is shared by two synchronized methods of a class?
#################Response:


5.	Which are the reasons for a thread to be blocked?
#################Response:


6.	How can you stop a thread?
#################Response:


7.	Which are the differences between wait and sleep?
#################Response:


8.	Which are the differences between wait and calling a synchronized method (or entering a synchronized block)?
#################Response:


9.	How can you stop a thread from waiting?
#################Response:


10.	What is a race condition?
#################Response:



	Problems


1.	Create an example where there are two synchronized sections in a class and they still can be run in parallel.
Done ->

2.	Prove that the example Restaurant does not work correctly in case there is more than one waiter in the restaurant
Done ->

3.	Solve a single producer, single consumer problem using wait( ) and notify( ).
The producer must not overflow the receiver's buffer, which can happen if the producer is faster than the consumer.
If the consumer is faster than the producer, then it must not read the same data more than once.
Do not assume anything about the relative speeds of the producer or consumer.
Done ->

4.	Modify Restaurant.java so that multiple WaitPersons generate order requests to multiple Chefs,
who produce orders and notify the WaitPerson who generated the request.
You'll need to use queues for both incoming order requests and outgoing orders.
Done ->
